{"ast":null,"code":"/**\n * This is used to determine the start and end of a selection range so\n * we can get the nodes between the two border nodes.\n *\n * It finds the nodes' common ancestor using\n * a naive implementation of a lowest common ancestor algorithm\n * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n * so we can compare their indexes to work out which node comes first in a depth first search.\n * (https://en.wikipedia.org/wiki/Depth-first_search)\n *\n * Another way to put it is which node is shallower in a trémaux tree\n * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n */\nexport const findOrderInTremauxTree = (instance, nodeAId, nodeBId) => {\n  if (nodeAId === nodeBId) {\n    return [nodeAId, nodeBId];\n  }\n  const nodeA = instance.getNode(nodeAId);\n  const nodeB = instance.getNode(nodeBId);\n  if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n    return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n  }\n  const aFamily = [nodeA.id];\n  const bFamily = [nodeB.id];\n  let aAncestor = nodeA.parentId;\n  let bAncestor = nodeB.parentId;\n  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n  let continueA = true;\n  let continueB = true;\n  while (!bAncestorIsCommon && !aAncestorIsCommon) {\n    if (continueA) {\n      aFamily.push(aAncestor);\n      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n      continueA = aAncestor !== null;\n      if (!aAncestorIsCommon && continueA) {\n        aAncestor = instance.getNode(aAncestor).parentId;\n      }\n    }\n    if (continueB && !aAncestorIsCommon) {\n      bFamily.push(bAncestor);\n      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n      continueB = bAncestor !== null;\n      if (!bAncestorIsCommon && continueB) {\n        bAncestor = instance.getNode(bAncestor).parentId;\n      }\n    }\n  }\n  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n  const ancestorFamily = instance.getChildrenIds(commonAncestor);\n  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n};","map":{"version":3,"names":["findOrderInTremauxTree","instance","nodeAId","nodeBId","nodeA","getNode","nodeB","parentId","id","aFamily","bFamily","aAncestor","bAncestor","aAncestorIsCommon","indexOf","bAncestorIsCommon","continueA","continueB","push","commonAncestor","ancestorFamily","getChildrenIds","aSide","bSide"],"sources":["/Users/xander/node_modules/@mui/x-tree-view/internals/plugins/useTreeViewSelection/useTreeViewSelection.utils.js"],"sourcesContent":["/**\n * This is used to determine the start and end of a selection range so\n * we can get the nodes between the two border nodes.\n *\n * It finds the nodes' common ancestor using\n * a naive implementation of a lowest common ancestor algorithm\n * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n * so we can compare their indexes to work out which node comes first in a depth first search.\n * (https://en.wikipedia.org/wiki/Depth-first_search)\n *\n * Another way to put it is which node is shallower in a trémaux tree\n * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n */\nexport const findOrderInTremauxTree = (instance, nodeAId, nodeBId) => {\n  if (nodeAId === nodeBId) {\n    return [nodeAId, nodeBId];\n  }\n  const nodeA = instance.getNode(nodeAId);\n  const nodeB = instance.getNode(nodeBId);\n  if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n    return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n  }\n  const aFamily = [nodeA.id];\n  const bFamily = [nodeB.id];\n  let aAncestor = nodeA.parentId;\n  let bAncestor = nodeB.parentId;\n  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n  let continueA = true;\n  let continueB = true;\n  while (!bAncestorIsCommon && !aAncestorIsCommon) {\n    if (continueA) {\n      aFamily.push(aAncestor);\n      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n      continueA = aAncestor !== null;\n      if (!aAncestorIsCommon && continueA) {\n        aAncestor = instance.getNode(aAncestor).parentId;\n      }\n    }\n    if (continueB && !aAncestorIsCommon) {\n      bFamily.push(bAncestor);\n      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n      continueB = bAncestor !== null;\n      if (!bAncestorIsCommon && continueB) {\n        bAncestor = instance.getNode(bAncestor).parentId;\n      }\n    }\n  }\n  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n  const ancestorFamily = instance.getChildrenIds(commonAncestor);\n  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}